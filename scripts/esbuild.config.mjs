import esbuild from "esbuild";
import process from "process";
import postcss from "postcss";
import postcssNesting from "postcss-nesting";
import chokidar from "chokidar";
import builtins from "builtin-modules";
import fs from "fs-extra";
import path from "path";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const VAULT_DIR = "/mnt/c/Users/Lev/Obsidian/Dev Vault";
const FILES = ["main.js", "manifest.json", "styles.css"];

const prod = process.argv[2] === "production";
// const prod = true;

const renamePlugin = () => ({
  name: "rename-plugin",
  setup(build) {
    build.onEnd(async (result) => {
      const file = build.initialOptions.outfile;
      const parent = path.dirname(file);
      const cssFileName = path.join(parent, "main.css");
      const newCssFileName = path.join(parent, "styles.css");

      if (fs.existsSync(cssFileName)) {
        try {
          if (fs.existsSync(newCssFileName)) {
            fs.unlinkSync(newCssFileName);
          }
          fs.renameSync(cssFileName, newCssFileName);
        } catch (e) {
          console.error("Failed to rename CSS file:", e);
        }
      }
    });
  },
});

const cssReBuild = () => ({
  name: "css-rebuild",

  setup(build) {
    // æ³¨å†Œä¸€ä¸ªåŠ è½½å™¨ï¼Œç”¨äºŽå¤„ç†æ‰€æœ‰ CSS æ–‡ä»¶
    // filter å‚æ•°æ˜¯ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼ŒåŒ¹é…æ‰€æœ‰ .css æ‰©å±•åçš„æ–‡ä»¶
    build.onLoad({ filter: /\.css$/ }, async (args) => {
      try {
        // è¯»å– CSS æ–‡ä»¶å†…å®¹
        // args.path åŒ…å«å½“å‰å¤„ç†çš„ CSS æ–‡ä»¶çš„å®Œæ•´è·¯å¾„
        const css = await fs.promises.readFile(args.path, "utf8");

        // ä½¿ç”¨ PostCSS å¤„ç† CSS æ–‡ä»¶
        // postcssNesting æ’ä»¶å…è®¸åœ¨ CSS ä¸­ä½¿ç”¨åµŒå¥—è¯­æ³•ï¼ˆç±»ä¼¼ SCSSï¼‰
        const result = await postcss([postcssNesting]).process(css, {
          from: args.path, // æŒ‡å®šæºæ–‡ä»¶è·¯å¾„ï¼Œç”¨äºŽç”Ÿæˆæ­£ç¡®çš„æºæ˜ å°„
        });

        // èŽ·å–è¾“å‡ºç›®å½•è·¯å¾„
        // build.initialOptions.outfile æ˜¯æœ€ç»ˆ JS è¾“å‡ºæ–‡ä»¶çš„è·¯å¾„
        const outDir = path.dirname(build.initialOptions.outfile);

        // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨ï¼Œå¦‚æžœä¸å­˜åœ¨åˆ™åˆ›å»º
        if (!fs.existsSync(outDir)) {
          fs.mkdirSync(outDir, { recursive: true });
        }

        // è¿”å›žå¤„ç†åŽçš„ CSS å†…å®¹
        // contents: å¤„ç†åŽçš„ CSS ä»£ç 
        // loader: å‘Šè¯‰ esbuild å¦‚ä½•è§£é‡Šè¿™äº›å†…å®¹ï¼ˆä½œä¸º CSSï¼‰
        return {
          contents: result.css,
          loader: "css",
        };
      } catch (error) {
        // é”™è¯¯å¤„ç†ï¼šå¦‚æžœ CSS å¤„ç†è¿‡ç¨‹ä¸­å‡ºçŽ°ä»»ä½•é”™è¯¯
        console.error("Error processing CSS:", error);

        // è¿”å›žç©ºå†…å®¹ï¼Œé¿å…æž„å»ºå®Œå…¨å¤±è´¥
        // è¿™æ ·å³ä½¿ CSS å¤„ç†å¤±è´¥ï¼Œæž„å»ºè¿‡ç¨‹ä»ç„¶å¯ä»¥ç»§ç»­
        return {
          contents: "",
          loader: "css",
        };
      }
    });
  },
});

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  plugins: [renamePlugin(), cssReBuild()],
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2020",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  // sourcemap: false,
  treeShaking: true,
  outfile: "main.js",
  minify: prod,
  // minify: true,
  loader: {
    ".ttf": "base64",
  },
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();

  const pluginDir = path.join(
    VAULT_DIR,
    ".obsidian/plugins/ace-code-editor",
  );
  console.log(`ðŸ“ Creating ${pluginDir} (if not existed)`);
  fs.mkdirSync(pluginDir, { recursive: true });

  const hotreloadPath = path.join(pluginDir, ".hotreload", "");
  console.log(`ðŸŒ¶ Creating a ${hotreloadPath}`);
  fs.writeFileSync(hotreloadPath, "");

  const watcher = chokidar.watch(FILES, { atomic: true, awaitWriteFinish: true, persistent: true });
  watcher
    .on("add", (p) => {
      console.log(`â™¨  ${p} is added`);
      fs.copyFileSync(p, path.join(pluginDir, p));
    })
    .on("change", (p) => {
      console.log(`â™¨  ${p} is changed`);
      fs.copyFileSync(p, path.join(pluginDir, p));
    });
}
